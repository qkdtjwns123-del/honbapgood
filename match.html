<!-- filename: match.html -->
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>혼밥러 · 매칭</title>
    <link rel="stylesheet" href="style.css" />
</head>
<body>
    <div class="container">
        <header class="page-header">
            <h1 class="title">🍚 혼밥러 · 매칭</h1>
            <p class="muted" style="margin-top:4px">
                “혼밥러 찾기”를 누르면 대기열에 들어가고,<br />
                매칭되면 <b>1단계: 수락/거절</b> 절차를 진행합니다.
            </p>
        </header>

        <div class="card" style="max-width:560px">
            <div id="filters" class="row" style="gap:16px; flex-wrap:wrap; margin-bottom:12px">
                <label class="chip"><input id="yearSame" type="checkbox" /> 학번 같게</label>
                <label class="chip"><input id="majorSame" type="checkbox" /> 학과 같게</label>
                <label class="chip"><input id="ageSame" type="checkbox" /> 나이 같게</label>
                <label class="chip"><input id="genderSame" type="checkbox" /> 성별 같게</label>
                <label class="chip"><input id="freeOverlap" type="checkbox" /> 공강 겹침 우선</label>
                <label class="chip"><input id="onlineOnly" type="checkbox" /> 동시접속만</label>
            </div>

            <div class="row" style="gap:12px; margin-bottom:8px">
                <button id="startBtn" class="btn outline">혼밥러 찾기</button>
                <button id="leaveBtn" class="btn outline">나가기</button>
                <button id="reopenBtn" class="btn outline" style="display:none">채팅방 열기</button>
            </div>

            <p id="status" class="muted" style="min-height:20px"></p>

            <!-- 1단계: 매칭 수락/거절 UI -->
            <div id="acceptArea" class="row" style="gap:12px; margin-top:8px; display:none">
                <button id="acceptYesBtn" class="btn" style="width:auto;min-width:120px">수락</button>
                <button id="acceptNoBtn" class="btn outline" style="width:auto;min-width:120px">거절</button>
            </div>

            <!-- 2단계 UI는 사용하지 않지만 기존 코드 유지 -->
            <div id="startArea" class="row" style="gap:12px; margin-top:8px; display:none">
                <button id="startYesBtn" class="btn" style="width:auto;min-width:140px">채팅 시작 (Y)</button>
                <button id="startNoBtn" class="btn outline" style="width:auto;min-width:140px">채팅 시작 안 함 (N)</button>
            </div>

            <div class="row" style="gap:8px; margin-top:8px">
                <a class="btn outline" href="community.html">커뮤니티</a>
                <a class="btn outline" href="profile.html">프로필</a>
                <a class="btn outline" href="index.html">홈</a>
                <a class="btn outline" href="bot.html">봇</a>
            </div>
        </div>
    </div>

    <script type="module">
        const $ = (id) => document.getElementById(id);

        const say = (m, ok = true) => {
            const el = $('status');
            el.textContent = m || '';
            el.style.color = ok ? 'var(--text-muted,#9fb7d0)' : '#ff6b6b';
        };

        async function ensureFbReady(timeoutMs = 8000) {
            if (window.fb) return window.fb;

            const readyP =
                (window.fbReady && typeof window.fbReady.then === 'function')
                    ? window.fbReady
                    : new Promise((resolve, reject) => {
                        const st = Date.now();
                        const iv = setInterval(() => {
                            if (window.fb) {
                                clearInterval(iv);
                                resolve(window.fb);
                            }
                            if (Date.now() - st > timeoutMs) {
                                clearInterval(iv);
                                reject(new Error('firebase 로더가 준비되지 않았어요.'));
                            }
                        }, 100);
                    });

            const timeoutP = new Promise((_, rej) =>
                setTimeout(() => rej(new Error('firebase 로더가 준비되지 않았어요.')), timeoutMs)
            );

            return await Promise.race([readyP, timeoutP]);
        }

        // 마지막 채팅방 다시 열기 버튼
        const lastRoomId = localStorage.getItem('lastRoomId');
        if (lastRoomId) {
            const b = $('reopenBtn');
            b.style.display = 'inline-block';
            b.addEventListener('click', () => {
                location.href = `chat.html?room=${encodeURIComponent(lastRoomId)}`;
            });
        }

        let finding = false;
        let cancelRequested = false;

        const filterIds = [
            'yearSame', 'majorSame', 'ageSame',
            'genderSame', 'freeOverlap', 'onlineOnly'
        ];

        const setFiltersDisabled = (d) => {
            const box = $('filters');
            box?.setAttribute('aria-disabled', d ? 'true' : 'false');
            filterIds.forEach(id => {
                const el = $(id);
                if (el) el.disabled = d;
            });
        };

        const setFindingUI = (on) => {
            const s = $('startBtn');
            s.classList.toggle('loading', on);
            s.textContent = on ? '매칭 중' : '혼밥러 찾기';
            s.disabled = on;
            setFiltersDisabled(on);
        };

        const acceptArea = $('acceptArea');
        const acceptYesBtn = $('acceptYesBtn');
        const acceptNoBtn = $('acceptNoBtn');

        const startArea = $('startArea');
        const startYesBtn = $('startYesBtn');
        const startNoBtn = $('startNoBtn');

        const hideAllSteps = () => {
            acceptArea.style.display = 'none';
            startArea.style.display = 'none';
        };

        const disableAcceptBtns = (d) => {
            acceptYesBtn.disabled = d;
            acceptNoBtn.disabled = d;
        };
        const disableStartBtns = (d) => {
            startYesBtn.disabled = d;
            startNoBtn.disabled = d;
        };

        let fbInstance = null;
        let myUid = null;
        let currentRoomId = null;
        let phase = 'idle';   // idle | queue | accept | start

        $('startBtn').addEventListener('click', () => {
            // async 함수 이벤트 핸들러 에러를 안전하게 처리
            onStart().catch(e => {
                console.error(e);
                const msg = e?.message || String(e || '');
                if (msg) {
                    if (msg.includes('패널티 5회 누적으로')) {
                        // 이용 제한 안내 문구는 그대로 노출
                        say(msg, false);
                    } else {
                        say('시작 실패: ' + msg, false);
                    }
                }
            });
        });
        $('leaveBtn').addEventListener('click', onLeave);

        window.addEventListener('beforeunload', async () => {
            try {
                const fb = await ensureFbReady(500);
                await fb.cancelMatching();
            } catch { }
        });

        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'hidden') {
                try {
                    const fb = await ensureFbReady(500);
                    await fb.markLeaving();
                } catch { }
            }
        });

        async function onStart() {
            if (finding) return;

            finding = true;
            cancelRequested = false;
            hideAllSteps();
            setFindingUI(true);
            say('대기열에 등록했습니다. 매칭 중…');

            try {
                const fb = await ensureFbReady();
                fbInstance = fb;

                const u = await fb.requireAuth();
                myUid = u?.uid || null;

                const opts = {
                    yearSame: $('yearSame').checked,
                    majorSame: $('majorSame').checked,
                    ageSame: $('ageSame').checked,
                    genderSame: $('genderSame').checked,
                    freeOverlap: $('freeOverlap').checked,
                    onlineOnly: $('onlineOnly').checked,
                };

                const { id: roomId } = await fb.startMatching(opts);
                if (cancelRequested) {
                    cleanup(true);
                    return;
                }

                currentRoomId = roomId;
                phase = 'accept';
                finding = false;

                setupAcceptUI();
            } catch (e) {
                console.error(e);
                const msg = e?.message || String(e || '');
                if (msg.includes('패널티 5회 누적으로')) {
                    // ✅ 이용 제한일 때: 남은 시간 안내까지 그대로 표시
                    say(msg, false);
                } else {
                    say('시작 실패: ' + msg, false);
                }
                // 메시지는 유지하고 나머지만 정리
                cleanup(false, true);
            }
        }

        function setupAcceptUI() {
            if (!currentRoomId || !fbInstance) return;
            hideAllSteps();
            acceptArea.style.display = 'flex';
            disableAcceptBtns(false);
            say('매칭이 성사되었습니다. 아래 버튼으로 수락/거절을 선택해주세요.');

            acceptYesBtn.onclick = () => handleAccept(true);
            acceptNoBtn.onclick = () => handleAccept(false);
        }

        async function handleAccept(yes) {
            if (phase !== 'accept' || !fbInstance || !currentRoomId) return;
            const fb = fbInstance;
            const roomId = currentRoomId;

            try {
                disableAcceptBtns(true);
                if (yes) {
                    await fb.acceptMatch(roomId);
                } else {
                    await fb.declineMatch(roomId);
                }

                say('상대방의 수락 여부를 기다리는 중입니다…');
                const { accepted, declinedBy } = await fb.readyToAccept(roomId, 30);
                acceptArea.style.display = 'none';

                if (!accepted) {
                    if (declinedBy === myUid) {
                        // 내가 거절 → 패널티 부여
                        try {
                            await fb.applyPenalty();
                            // 이후 프로필을 다시 읽어서 이용 제한 여부 확인
                            let msg = '거절하여 패널티가 1회 부과되었습니다.';
                            try {
                                const prof = await fb.loadProfile?.().catch(() => null);
                                const rawUntil = prof?.penaltyUntil || null;
                                const until = rawUntil?.toDate ? rawUntil.toDate() : rawUntil;
                                if (until && until.getTime() > Date.now()) {
                                    msg = '패널티 5회 누적으로 1시간 동안 이용이 제한됩니다.';
                                }
                            } catch { }
                            say(msg, false);
                        } catch {
                            say('거절하여 패널티가 1회 부과되었습니다.', false);
                        }
                    } else {
                        say('상대방이 거절하였습니다.', false);
                    }
                    phase = 'idle';
                    currentRoomId = null;
                    setFindingUI(false);
                    return;
                }

                // ✅ 양쪽 모두 수락(= 채팅 시작) → 매칭 스코어 1회 증가 후 채팅방 이동
                phase = 'idle';
                setFindingUI(false);

                try {
                    const res = await fb.addMatchSuccess();
                    if (res && res.rewarded) {
                        alert('축하합니다! 매칭 스코어 ★★★ 달성! 소정의 상품이 지급될 예정입니다. 🎉');
                    }
                } catch {
                    // 매칭 스코어 업데이트는 실패해도 채팅은 진행
                }

                try { localStorage.setItem('lastRoomId', roomId); } catch { }
                say('채팅방으로 이동합니다…');
                await fb.gotoRoom(roomId);
                return;

            } catch (e) {
                console.error(e);
                say('수락 단계에서 오류가 발생했습니다: ' + (e?.message || e), false);
                phase = 'idle';
                currentRoomId = null;
                setFindingUI(false);
            } finally {
                disableAcceptBtns(false);
            }
        }

        async function onLeave() {
            cancelRequested = true;
            finding = false;
            phase = 'idle';
            currentRoomId = null;
            hideAllSteps();
            setFindingUI(false);

            try {
                const fb = fbInstance || await ensureFbReady();
                await fb.cancelMatching();
                say('대기열에서 나갔어요.');
            } catch (e) {
                console.error(e);
                say('나가기 실패: ' + (e?.message || e), false);
            }
        }

        function cleanup(alsoCancel = false, keepMessage = false) {
            // ❗ 에러 메시지를 유지하고 싶은 상황에서는 keepMessage=true 로 호출
            if (!cancelRequested && !keepMessage) {
                say('');
            }
            finding = false;
            phase = 'idle';
            hideAllSteps();
            setFindingUI(false);

            if (alsoCancel && fbInstance) {
                (async () => {
                    try {
                        await fbInstance.cancelMatching();
                    } catch { }
                })();
            }
        }
    </script>

    <!-- 순서 고정: config → firebase -->
    <script src="config.js?v=28"></script>
    <script type="module" src="firebase.js?v=33"></script>
</body>
</html>
